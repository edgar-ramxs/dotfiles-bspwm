#!/bin/sh

#     ███████╗██╗   ██╗███╗   ██╗ ██████╗████████╗██╗ ██████╗ ███╗   ██╗███████╗
#     ██╔════╝██║   ██║████╗  ██║██╔════╝╚══██╔══╝██║██╔═══██╗████╗  ██║██╔════╝
#     █████╗  ██║   ██║██╔██╗ ██║██║        ██║   ██║██║   ██║██╔██╗ ██║███████╗
#     ██╔══╝  ██║   ██║██║╚██╗██║██║        ██║   ██║██║   ██║██║╚██╗██║╚════██║
#  ██╗██║     ╚██████╔╝██║ ╚████║╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║███████║
#  ╚═╝╚═╝      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝

function message() {
    local signal color
    local RESETC="\033[0m\e[0m"
    declare -A COLORS=(
        [-title]="\033[0;37m\033[1m [$]"
        [-subtitle]="\033[0;35m\033[1m [*]"
        [-approval]="\033[38;5;51m\033[1m [?]"
        [-cancel]="\033[0;34m\033[1m [!]"
        [-success]="\033[0;32m\033[1m [+]"
        [-warning]="\033[0;33m\033[1m [&]"
        [-error]="\033[0;31m\033[1m [-]"
    )
    local type="$1"
    shift
    local value="${COLORS[$type]}"
    if [[ -n "$value" ]]; then
        echo -e "${value} $*${RESETC}"
    else
        echo -e "$*${RESETC}"
    fi
}

function extract-files() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        message -error "'$file' is not a valid file!"
        return 1
    fi
    case "$file" in
        *.tar.bz2)  tar xvjf "$file" ;;
        *.tar.gz)   tar xvzf "$file" ;;
        *.tbz2)     tar xvjf "$file" ;;
        *.tgz)      tar xvzf "$file" ;;
        *.tar)      tar xvf "$file" ;;
        *.bz2)      bunzip2 "$file" ;;
        *.gz)       gunzip "$file" ;;
        *.zip)      unzip "$file" ;;
        *.rar)      unrar x "$file" ;;
        *.Z)        uncompress "$file" ;;
        *.7z)       7z x "$file" ;;
        *)          message -warning "Don't know how to extract '$file'..." ;;
    esac
}

function mkt() {
    local dirs=(scanner content exploits scripts)
    for dir in "${dirs[@]}"; do
        if [[ -d "$dir" ]]; then
            message -warning "Directory '$dir' already exists, skipping..."
        else
            mkdir -p "$dir" && message -success "Created directory '$dir'"
        fi
    done
}

function cdu() {
    local count="${1:-1}"  # valor por defecto = 1
    local path
    if ! [[ "$count" =~ ^[0-9]+$ ]]; then
        message -error "Usage: cdu <positive-integer>"
        return 1
    fi
    
    path=$(printf '../%.0s' $(seq 1 "$count"))
    cd "$path" || {
        message -error "No se pudo cambiar al directorio: $path"
        return 1
    }
}

function cdl() {
    if [[ -z "$1" ]]; then
        message -error "No directory specified."
        return 1
    fi
    if cd "$@"; then
        ls --color=auto -lah
    else
        message -error "Failed to change directory to '$*'"
        return 1
    fi
}

function cdir() {
    local dir="$1"
    if [[ -z "$dir" ]]; then
        message -warning "Usage: cdir <directory-name>"
        return 1
    fi

    if [[ -d "$dir" ]]; then
        message -warning "Directory '$dir' already exists. Switching to it..."
    else
        mkdir -p "$dir" && message -success "Created directory '$dir'"
    fi

    cd "$dir" || {
        message -error "Failed to enter directory '$dir'"
        return 1
    }
}

function rmk() {
    local file="$1"
    if [[ -z "$file" ]]; then
        message -warning "Usage: rmk <file>"
        return 1
    fi

    if [[ ! -e "$file" ]]; then
        message -error "File '$file' does not exist."
        return 1
    fi

    if [[ ! -f "$file" ]]; then
        message -error "'$file' is not a regular file."
        return 1
    fi

    message -subtitle "Securely erasing '$file'..."
    scrub -p dod "$file" && message -success "scrub completed." || message -error "scrub failed."
    shred -zun 10 -v "$file" && message -success "shred completed." || message -error "shred failed."
}


function extract-ports() {
	ports="$(cat $1 | grep -oP '\d{1,5}/open' | awk '{print $1}' FS='/' | xargs | tr ' ' ',')"
	ip_address="$(cat $1 | grep -oP '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}' | sort -u | head -n 1)"
	echo -e "\n[*] Extracting information...\n" > extractPorts.tmp
	echo -e "\t[*] IP Address: $ip_address"  >> extractPorts.tmp
	echo -e "\t[*] Open ports: $ports\n"  >> extractPorts.tmp
	echo $ports | tr -d '\n' | xclip -sel clip
	echo -e "[*] Ports copied to clipboard\n"  >> extractPorts.tmp
	cat extractPorts.tmp; rm extractPorts.tmp
}

function open-file() {
    local file="$1"
    if [[ -z "$file" ]]; then
        message -warning "Uso: open-file <archivo>"
        return 1
    fi

    if [[ -z "$EDITOR" ]]; then
        message -warning "La variable \$EDITOR no está definida."
        return 1
    fi

    case "$EDITOR" in
        code|vim|nvim|nano|micro|helix|hx)
            if command -v "$EDITOR" &>/dev/null; then
                "$EDITOR" "$file"
            else
                message -error "El editor '$EDITOR' no está instalado."
                return 1
            fi
            ;;
        *)
            message -error "Editor no soportado: '$EDITOR'."
            return 1
            ;;
    esac
}

function create-venv() {
    local dir_name=$(basename "$(pwd)")
    local env_name=$(echo "$dir_name" | tr '[:upper:]' '[:lower:]' | iconv -f utf8 -t ascii//TRANSLIT)
    env_name=".$env_name-env"
    
    python3 -m venv "$env_name"
    if [ $? -ne 0 ]; then
        message -error "Failed to create virtual environment."
        return 1
    fi
    
    source "$env_name/bin/activate"
    if [ $? -ne 0 ]; then
        message -error "Failed to activate virtual environment."
        return 1
    fi
    
    message -success "Virtual environment '$env_name' created and activated."
}

function get-venv-name() {
    local dir_name=$(basename "$(pwd)")
    echo -e ".$(echo "$dir_name" | tr '[:upper:]' '[:lower:]' | iconv -f utf8 -t ascii//TRANSLIT)-env"
}

function settarget(){
    if [ $# -eq 1 ]; then
        echo $1 > ~/.config/rofi/htb/mark-name
        elif [ $# -gt 2 ]; then
        echo "settarget [IP] [NAME] | settarget [IP]"
    else
        echo $1 $2 > ~/.config/rofi/htb/mark-name
    fi
}

function fzf-lovely() {
    local layout=""
    if [[ "$1" == "h" ]]; then
        layout="--reverse --preview-window=down:20"
    fi

    fzf -m $layout --preview '
        [[ $(file --mime {}) =~ binary ]] &&
            echo "{} is a binary file" ||
            (bat --style=numbers --color=always {} ||
             highlight -O ansi -l {} ||
             coderay {} ||
             rougify {} ||
             cat {}) 2>/dev/null | head -500
    '
}

function compile-pls() {
    local file="$1"
    if [[ -z "$file" ]]; then
        message -cancel "Error: Debes proporcionar un archivo."
        return 1
    elif [[ ! -f "$file" ]]; then
        message -cancel "Error: El archivo '$file' no existe."
        return 1
    fi

    local filename=$(basename -- "$file")
    local extension="${filename##*.}"
    local name="${filename%.*}"
    command_exists() {
        command -v "$1" &>/dev/null
    }

    case "$extension" in
        kt)
            if command_exists kotlinc && command_exists java; then
                kotlinc "$file" -include-runtime -d "${name}.jar" && java -jar "${name}.jar"
            else
                message -cancel "Error: Kotlin y/o Java no están instalados."
                return 1
            fi
            ;;
        java)
            if command_exists javac && command_exists java; then
                javac "$file" && java "$name"
            else
                message -cancel "Error: Java no está instalado."
                return 1
            fi
            ;;
        cpp)
            if command_exists g++; then
                g++ "$file" -o "$name" && "./$name"
            else
                message -cancel "Error: g++ no está instalado."
                return 1
            fi
            ;;
        c)
            if command_exists gcc; then
                gcc "$file" -o "$name" && "./$name"
            else
                message -cancel "Error: gcc no está instalado."
                return 1
            fi
            ;;
        pas)
            if command_exists fpc; then
                fpc "$file" && "./$name"
            else
                message -cancel "Error: Free Pascal Compiler (fpc) no está instalado."
                return 1
            fi
            ;;
        *)
            message -cancel "Error: Extensión de archivo no admitida: .$extension"
            return 1
            ;;
    esac
}

function initialize_git_repo() {
    local repo_name=""
    local readme_message="Proyecto inicializado"
    local remote_url=""
    local branch="main"
    local original_dir
    original_dir="$(pwd)"

    # Parsear opciones
    while getopts "n:m:r:b:" opt; do
        case "$opt" in
            n) repo_name="$OPTARG" ;;
            m) readme_message="$OPTARG" ;;
            r) remote_url="$OPTARG" ;;
            b) branch="$OPTARG" ;;
            \?) message -error "Uso: initialize_git_repo -n <repo_name> [-m <readme_message>] [-r <remote_url>] [-b <branch>]"
                return 1 ;;
        esac
    done

    if [[ -z "$repo_name" ]]; then
        message -error "Error: Debes proporcionar un nombre para el repositorio con -n."
        return 1
    fi

    # Crear y entrar al directorio
    if ! mkdir -p "$repo_name"; then
        message -error "Error al crear el directorio '$repo_name'."
        return 1
    fi

    cd "$repo_name" || { message -error "No se pudo acceder al directorio '$repo_name'."; return 1; }

    # Inicializar git
    if ! git init &>/dev/null; then
        message -error "Error al inicializar el repositorio git."
        cd "$original_dir"
        return 1
    fi

    # Crear .gitignore y README.md
    echo -e ".vscode/" > .gitignore
    {
        echo "# $repo_name"
        echo "$readme_message"
    } > README.md

    git add . 
    git commit -m "Initial commit" &>/dev/null

    # Configurar remoto y push
    if [[ -n "$remote_url" ]]; then
        if ! git remote add origin "$remote_url"; then
            message -warning "No se pudo agregar el remoto '$remote_url'."
        else
            git branch -M "$branch"
            if ! git push -u origin "$branch"; then
                message -warning "No se pudo hacer push al remoto."
            fi
        fi
    fi

    cd "$original_dir" || return 1

    message -success "Repositorio '$repo_name' inicializado correctamente."
}


function function tell-me-a-joke() {
    local response category type joke setup delivery
    response=$(curl -sSL https://v2.jokeapi.dev/joke/Any) || {
        message -error "Failed to fetch joke."
        return 1
    }

    category=$(jq -r '.category' <<< "$response")
    type=$(jq -r '.type' <<< "$response")
    message -approval "[Joke - $category]"

    case "$type" in
        single)
            joke=$(jq -r '.joke' <<< "$response")
            echo "$joke"
            ;;
        twopart)
            setup=$(jq -r '.setup' <<< "$response")
            delivery=$(jq -r '.delivery' <<< "$response")
            echo "$setup"
            echo "$delivery"
            ;;
        *)
            message -error "Unexpected joke format."
            return 1
            ;;
    esac
}

function function pray-for-me() {
    local response book chapter verse text translation_name
    response=$(curl -s https://bible-api.com/data/web/random) || {
        message -error "Failed to fetch verse."
        return 1
    }

    translation_name=$(jq -r '.translation.name' <<< "$response")
    book=$(jq -r '.random_verse.book' <<< "$response")
    chapter=$(jq -r '.random_verse.chapter' <<< "$response")
    verse=$(jq -r '.random_verse.verse' <<< "$response")
    text=$(jq -r '.random_verse.text' <<< "$response")

    if [[ -z "$text" || "$text" == "null" ]]; then
        message -error "No verse found in response."
        return 1
    fi

    message -approval "[Verse from $translation_name]"
    echo "\"$text\""
    echo "— $book $chapter:$verse"
}

function cheat() {
    local search=$1
	curl -s "cheat.sh/$search" | cat
}

function wttr() {
    local idioma="es"
    local opciones="2mp"
    local ubicacion="Santiago+de+chile"
    curl -s "wttr.in/$ubicacion?$opciones&lang=$idioma"
}

function calc () {
    local operation=$1
    echo "$operation" | bc -ql
}

function crypto-rate() {
    # Colores ANSI
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    CYAN='\033[0;36m'
    BOLD='\033[1m'
    RESET='\033[0m'

    # Códigos LATAM
    declare -A latam_currencies=(
        ["CLP"]="Chile"
        ["COP"]="Colombia"
        ["BRL"]="Brasil"
        ["ARS"]="Argentina"
        ["MXN"]="México"
        ["PEN"]="Perú"
    )

    # Globales
    declare -A global_currencies=(
        ["GBP"]="Reino Unido"
        ["AUD"]="Australia"
        ["JPY"]="Japón"
        ["ZAR"]="Sudáfrica"
        ["CHF"]="Suiza"
        ["INR"]="India"
        ["CNY"]="China"
        ["EUR"]="Unión Europea"
        ["CAD"]="Canadá"
        ["NZD"]="Nueva Zelanda"
    )

    echo -e "\n${CYAN}${BOLD}Tasas de cambio (1 USD = moneda local):${RESET}"
    rates_response=$(curl -s "https://api.coingecko.com/api/v3/exchange_rates")
    btc_usd=$(jq -r '.rates.usd.value' <<< "$rates_response")
    print_rate() {
        local code="$1"
        local country="$2"
        val=$(jq -r --arg c "${code,,}" '.rates[$c].value' <<< "$rates_response")
        unit=$(jq -r --arg c "${code,,}" '.rates[$c].unit' <<< "$rates_response")
        if [[ "$val" != "null" && "$unit" != "null" ]]; then
            usd_in_local=$(awk "BEGIN {printf \"%.4f\", $btc_usd / $val}")
            printf "    %-16s %-6s %10s %s\n" "$country" "($code)" "$usd_in_local" "$unit"
        fi
    }

    for code in "${!latam_currencies[@]}"; do
        print_rate "$code" "${latam_currencies[$code]}"
    done

    echo -e "\n${CYAN}${BOLD}Tasas de cambio globales:${RESET}"
    for code in "${!global_currencies[@]}"; do
        print_rate "$code" "${global_currencies[$code]}"
    done

    echo -e "\n${CYAN}${BOLD}Top 10 Criptomonedas (USD + variación):${RESET}"
    crypto_response=$(curl -s "https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=10&page=1&sparkline=false&price_change_percentage=1h,24h,7d")
    echo "$crypto_response" | jq -r '
      .[] | "\(.market_cap_rank)\t\(.symbol | ascii_upcase)\t\(.current_price)\t\(.price_change_percentage_1h_in_currency)\t\(.price_change_percentage_24h_in_currency)\t\(.price_change_percentage_7d_in_currency)"
    ' | while IFS=$'\t' read -r rank symbol price ch1h ch24h ch7d; do
        format_pct() {
            local pct="$1"
            if [[ "$pct" == "null" ]]; then
                echo "-"
            elif (( $(echo "$pct >= 0" | bc -l) )); then
                printf "${GREEN}▲ %.2f%%${RESET}" "$pct"
            else
                printf "${RED}▼ %.2f%%${RESET}" "${pct#-}"
            fi
        }

        printf "%2s. %-5s $%-10s  1h: %s | 24h: %s | 7d: %s\n" \
            "$rank" "$symbol" "$price" \
            "$(format_pct "$ch1h")" \
            "$(format_pct "$ch24h")" \
            "$(format_pct "$ch7d")"
    done
}
